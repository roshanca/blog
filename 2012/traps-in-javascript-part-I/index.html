<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>JavaScript 中的一些坑（一） - 肉山·察</title>
	<meta name="viewport" content="width=device-width">
	
	<link rel="canonical" href="http://roshanca.com/2012/traps-in-javascript-part-I">
	<link media="all" rel="stylesheet" href="/assets/styles/app.css" />
	<link href="//fonts.googleapis.com/css?family=Noto+Serif" rel="stylesheet">
	<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
	<script src="/assets/scripts/jquery.min.js"></script>
</head>
<body>

<header id="header" role="banner">
	<hgroup>
	
		<a href="/" class="blog-title">肉山·察</a>
		<div>
	<a href="//github.com/roshanca" class="social-link">
		<i class="fa fa-github"></i>
	</a>

	<a href="//twitter.com/roshan_wu" class="social-link">
		<i class="fa fa-twitter"></i>
	</a>

	<a href="//weibo.com/jinfeixibi" class="social-link">
		<i class="fa fa-weibo"></i>
	</a>

	<a href="//www.flickr.com/photos/roshanca/" class="social-link">
		<i class="fa fa-flickr"></i>
	</a>
</div>
	
	</hgroup>
	<a href="/atom.xml" class="subscribe">
		<i class="fa fa-rss"></i>
	</a>
</header>

<main class="fluid" role="main">
	<article class="post" role="article">
		<header class="post-header">
			<h1 class="post-title">JavaScript 中的一些坑（一）</h1>
		</header>
		<section class="post-content">
			<p>“坑”这个字，在此的意思是“陷阱”。由于 JavaScript “弱语言”的性质，使得其在使用过程中异常的宽松灵活，但也极为容易“中招”。</p>

<h2>坑一：全局变量</h2>

<blockquote>
<p>JavaScript 通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。</p>
</blockquote>

<p>“未声明直接简单使用”，指的是不用 <code>var</code> 关键字来声明变量。这个我们已经非常清楚，避免造成隐式产生全局变量的方法就是声明变量尽量用 <code>var</code> 关键字。</p>

<p>可你以为用了 <code>var</code> 就 ok 了？来看看这个坑：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// body...</span>
<span class="p">}</span>
</code></pre></div>
<p>也许你期望得到的是两个局部变量，但 <code>b</code> 却是货真价实的全局变量。why? Because <strong>赋值运算是自右往左的</strong>，所以这相当于：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">(</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// body...</span>
<span class="p">}</span>
</code></pre></div>
<p>所以 <code>b</code> 是全局变量。</p>

<p>填坑：变量声明，最好一个个来，别搞批发~_~;</p>

<h2>坑二：变量声明</h2>

<p>先来看坑：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">myName</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">myName</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span>
</code></pre></div>
<p>乍看上去，我们预计期望两次 <code>alert</code> 的结果分别为 &quot;global&quot; 与 &quot;local&quot;，但真实的结果是 &quot;undefined&quot; 与 &quot;local&quot;。why? 因为：</p>

<blockquote>
<p>变量在同一作用域（同一函数）中，声明都是被提至作用域顶部先进行解析的。</p>
</blockquote>

<p>所以以上代码片段的执行行为可能就像这样：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">myName</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span> <span class="c1">// &quot;undefined&quot;</span>
    <span class="nx">myName</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span> <span class="c1">// &quot;local&quot;</span>
<span class="p">}</span>
</code></pre></div>
<p>用另一个坑来测试下你是否真的理解了预解析：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="k">in</span> <span class="nb">window</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</code></pre></div>
<p><code>a</code> 变量的声明被提前到了代码顶端，此时还未赋值。接下来进入 <code>if</code> 语句，判断条件中 <code>&quot;a&quot; in window</code> 已成立（<code>a</code> 已被声明为全局变量），所以判断语句计算结果为 <code>false</code>，直接就跳出 <code>if</code> 语句了，所以 <code>a</code> 的值为 <code>undefined</code>。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// &quot;undefined&quot;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="k">in</span> <span class="nb">window</span><span class="p">);</span> <span class="c1">// true</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="k">in</span> <span class="nb">window</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 不执行</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// &quot;undefined&quot;</span>
</code></pre></div>
<p>填坑：变量声明，最好手动置于作用域顶部，对于无法当下赋值的变量，可采取先声明后赋值的手法。</p>

<h2>坑三：函数声明</h2>

<blockquote>
<p>函数声明也是被提前至作用域顶部，先于任何表达式和语句被解析和求值的</p>
</blockquote>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span> <span class="c1">// &quot;function&quot;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// body...</span>
<span class="p">}</span>
</code></pre></div>
<p>可以对比一下：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span> <span class="c1">// &quot;undefined&quot;</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// body...</span>
<span class="p">};</span>
</code></pre></div>
<p>明白了这个道理的你，是否还会踩以下的坑呢？</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">test</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">test</span><span class="p">();</span>
</code></pre></div>
<p>运行以上代码片段，看到的两次弹窗显示的都是 &quot;2&quot;，为什么不是分别为 &quot;1&quot; 和 &quot;2&quot; 呢？很简单，<code>test</code> 的声明先于 <code>test()</code> 被解析，由于后者覆盖前者，所以两次执行的结果都是 &quot;2&quot;。</p>

<p>填坑：多数情况下，用函数表达式来代替函数声明是一个好习惯，特别是在一些语句块中。</p>

<h2>坑四：函数表达式</h2>

<p>先看命名函数表达式，理所当然，就是它得有名字，例如：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// body...</span>
<span class="p">};</span>
</code></pre></div>
<p>要注意的是：函数名只对其函数内部可见。如以下坑：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// 正常运行</span>
<span class="p">};</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// 出错：ReferenceError</span>
</code></pre></div>
<p>填坑：尽量少用命名函数表达式（除了一些递归以及 debug 的用途），切勿将函数名使用于外部。</p>

<h2>坑五：函数的自执行</h2>

<p>对于函数表达式，可以通过后面加上 <code>()</code> 立即执行。并且可在 <code>()</code> 中传递参数，而函数声明不可以。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// (1) 这只是一个分组操作符，不是函数调用！</span>
<span class="c1">// 所以这里函数未被执行，依旧是个声明</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>以下代码片段分别执行都弹窗显示 &quot;1&quot;，因为在 <code>(1)</code> 之前，都为函数表达式，所以这里的 <code>()</code> 非分组操作符，而为运算符，表示调用执行。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 标准的匿名函数表达式</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 前面的 () 将 function 声明转化为了表达式</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">})(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 整个 () 内为表达式</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// new 表达式</span>
<span class="k">new</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// &amp;&amp;, ||, !, +, -, ~ 等操作符（还有逗号），在函数表达式和函数声明上消除歧义</span>
<span class="c1">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span>
<span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span><span class="err">​</span>
</code></pre></div>
<p>填坑：要解决这个坑的关键在于，弄清楚形形色色的函数表达式之实质。</p>

<h2>坑六：循环中的闭包</h2>

<p>以下演示的是一个常见的坑：</p>

<iframe style="width: 100%; height: 300px" frameborder="0" seamless="seamless" src="http://jsfiddle.net/GNDd4/embedded/result,html,js/light/"></iframe>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;ul&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;You click link #&quot;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">);</span>        
    <span class="p">}</span>       
<span class="p">}</span>
</code></pre></div>
<p>我们预期当点击第 <code>i</code> 个链接时，得到此序列索引 <code>i</code> 的值，可实际无论点击哪个链接，得到的都是 <code>i</code> 在循环后的最终结果：&quot;5&quot;。</p>

<p>解释一下原因：当 <code>alert</code> 被调用时，<code>for</code> 循环内的匿名函数表达式，保持了对外部变量 <code>i</code> 的引用（闭包），此时循环已结束，<code>i</code> 的值被修改为 &quot;5&quot;。</p>

<p>填坑：为了得到想要的结果，需要在每次循环中创建变量 <code>i</code> 的拷贝。以下演示正确的做法：</p>

<iframe style="width: 100%; height: 300px" frameborder="0" seamless="seamless" src="http://jsfiddle.net/UTy8Z/embedded/result,html,js/light/"></iframe>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;ul&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
            <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;You click link #&quot;</span> <span class="o">+</span> <span class="nx">index</span><span class="p">);</span>        
        <span class="p">}</span>
    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>可以看到，<code>(function () { ... })()</code> 的形式，就是上文提到的<strong>函数的自执行</strong>，<code>i</code> 作为参数传给了 <code>index</code>，<code>alert</code> 再次执行时，它就拥有了对 <code>index</code> 的引用，此时这个值是不会被循环改变的。当然，明白了道理后，你也可以这样写：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">links</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
            <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;You click link #&quot;</span> <span class="o">+</span> <span class="nx">index</span><span class="p">);</span>        
        <span class="p">}</span>
    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>It works too.</p>

		</section>
		<footer class="post-footer">
			<div class="post-meta">
				<time datetime="2012-11-29 14:47:00 +0800" class="updated" pubdate>Nov 29, 2012</time>

				
<span class="post-tag">
	
		<span class="tag">javascript</span>
	
</span>


			</div>
		</footer>
	</article>
</main>

<footer id="footer" role="copyright">
	<p>© Copyright 2014 by Roshan Wu.</p>
</footer>

</body>
</html>
